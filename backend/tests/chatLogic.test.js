const { processMessage, suggestRecipes } = require('../src/chatLogic');

// Mock the ollamaService to avoid actual API calls
jest.mock('../src/ollamaService', () => ({
  chatWithOllama: jest.fn((message) => {
    return Promise.resolve(`Mock response for: ${message}`);
  }),
  suggestWithOllama: jest.fn(({ message, requestedCount = 3 }) => {
    const mockRecipes = [];
    for (let i = 0; i < requestedCount; i++) {
      mockRecipes.push({
        name: `Mock Recipe ${i + 1}`,
        ingredients: [
          { name: 'ingredient1', quantity: '1 cup' },
          { name: 'ingredient2', quantity: '2 tbsp' }
        ],
        steps: ['Step 1', 'Step 2'],
        autogenerated: true,
        mealType: 'dinner'
      });
    }
    return Promise.resolve({
      reply: `Here are ${requestedCount} recipes`,
      reasoning: 'Mock reasoning',
      recipes: mockRecipes
    });
  })
}));

// Mock data
const mockData = {
  products: [
    { item: 'Chicken', category: 'Meat', price: 5.99, _normalized: 'chicken', unit: 'per lb' },
    { item: 'Rice', category: 'Grains', price: 2.99, _normalized: 'rice', unit: 'per bag' },
    { item: 'Broccoli', category: 'Vegetables', price: 1.99, _normalized: 'broccoli', unit: 'per bunch' },
    { item: 'Eggs', category: 'Dairy', price: 3.49, _normalized: 'eggs', unit: 'per dozen' },
    { item: 'Milk', category: 'Dairy', price: 4.29, _normalized: 'milk', unit: 'per gallon' }
  ],
  recipes: [
    {
      name: 'Chicken Stir Fry',
      ingredients: [
        { name: 'chicken', quantity: '1 lb' },
        { name: 'rice', quantity: '2 cups' },
        { name: 'broccoli', quantity: '1 cup' }
      ],
      steps: 'Cook chicken, add veggies, serve over rice.',
      mealType: 'dinner'
    },
    {
      name: 'Veggie Omelette',
      ingredients: [
        { name: 'eggs', quantity: '3' },
        { name: 'broccoli', quantity: '1/2 cup' }
      ],
      steps: 'Beat eggs, cook with veggies, fold.',
      mealType: 'breakfast'
    }
  ]
};

describe('chatLogic - processMessage', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('should handle greeting messages', async () => {
    const result = await processMessage('Hello', mockData, {});
    expect(result.reply).toBeDefined();
    // Mock returns "Mock response for: hello", so check for that pattern
    expect(result.reply.toLowerCase()).toContain('mock');
    expect(result.recipes).toEqual([]);
  });

  test('should initialize context with seenRecipes Set', async () => {
    const result = await processMessage('hi', mockData, {});
    expect(result.context).toBeDefined();
    expect(result.context.seenRecipes).toBeInstanceOf(Set);
    expect(result.context.messages).toBeInstanceOf(Array);
  });

  test('should convert seenRecipes array to Set', async () => {
    const context = { seenRecipes: ['Recipe1', 'Recipe2'] };
    const result = await processMessage('hi', mockData, context);
    expect(result.context.seenRecipes).toBeInstanceOf(Set);
    expect(result.context.seenRecipes.has('Recipe1')).toBe(true);
  });

  test('should handle recipe requests', async () => {
    const result = await processMessage('give me 3 recipes', mockData, {});
    expect(result.reply).toBeDefined();
    expect(result.recipes).toBeDefined();
    expect(Array.isArray(result.recipes)).toBe(true);
  });

  test('should add user message to context', async () => {
    const result = await processMessage('show me recipes', mockData, {});
    expect(result.context.messages).toBeDefined();
    expect(result.context.messages.some(m => m.from === 'user')).toBe(true);
  });

  test('should handle shopping list queries', async () => {
    const context = {
      shoppingList: [
        { name: 'chicken', price: 5.99 },
        { name: 'rice', price: 2.99 }
      ]
    };
    const result = await processMessage('what is in my shopping list', mockData, context);
    expect(result.reply.toLowerCase()).toContain('shopping');
  });

  test('should handle "more" requests with previous context', async () => {
    const context = {
      lastNonMoreQuery: 'give me dinner recipes',
      messages: [
        { from: 'user', text: 'give me dinner recipes' },
        { from: 'bot', text: 'Here are some recipes' }
      ]
    };
    const result = await processMessage('more', mockData, context);
    expect(result.recipes).toBeDefined();
  });
});

describe('chatLogic - Flow Triggers', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('should trigger Nutrition Coach flow', async () => {
    const result = await processMessage('__NUTRITION_START__', mockData, {});
    expect(result.reply).toContain('Nutrition Coach');
    expect(result.reply).toContain('What I do:');
    expect(result.context.nutritionFlow).toBe('awaiting_height_weight');
  });

  test('should trigger Budget Planner flow', async () => {
    const result = await processMessage('__BUDGET_START__', mockData, {});
    expect(result.reply).toContain('Budget Planner');
    expect(result.reply).toContain('What I do:');
    expect(result.context.budgetFlow).toBe('awaiting_budget');
  });

  test('should trigger Time Saver flow', async () => {
    const result = await processMessage('__TIME_START__', mockData, {});
    expect(result.reply).toContain('Time Saver');
    expect(result.reply).toContain('What I do:');
    expect(result.context.timeFlow).toBe('awaiting_minutes');
  });

  test('should trigger Pantry Helper flow', async () => {
    const result = await processMessage('__PANTRY_START__', mockData, {});
    expect(result.reply).toContain('Pantry Helper');
    expect(result.reply).toContain('What I do:');
    expect(result.context.pantryFlow).toBe('awaiting_items');
  });

  test('should trigger Meal Prep flow', async () => {
    const result = await processMessage('__MEAL_PREP_START__', mockData, {});
    expect(result.reply).toContain('Meal Prep');
    expect(result.reply).toContain('What I do:');
    expect(result.context.mealPrepFlow).toBe('awaiting_preference');
  });

  test('should trigger Healthy Options flow', async () => {
    const result = await processMessage('__HEALTHY_START__', mockData, {});
    expect(result.reply).toContain('Healthy Options');
    expect(result.reply).toContain('What I do:');
    expect(result.context.healthyFlow).toBe('awaiting_topic');
  });

  test('should trigger Daily Menu flow', async () => {
    const result = await processMessage('__DAILY_MENU_START__', mockData, {});
    expect(result.reply).toContain('Full Day Menu');
    expect(result.reply).toContain('What I do:');
    // Daily Menu flow completes immediately, doesn't persist state
    // Just verify the response is correct
    expect(result.recipes).toBeDefined();
  });

  test('should clear other flows when new trigger is detected', async () => {
    const context = {
      nutritionFlow: 'awaiting_height_weight',
      budgetFlow: 'awaiting_budget'
    };
    const result = await processMessage('__TIME_START__', mockData, context);
    expect(result.context.nutritionFlow).toBeUndefined();
    expect(result.context.budgetFlow).toBeUndefined();
    expect(result.context.timeFlow).toBe('awaiting_minutes');
  });
});

describe('chatLogic - Budget Flow', () => {
  test('should handle budget input with servings', async () => {
    const context = { budgetFlow: 'awaiting_budget' };
    const result = await processMessage('$20 for 2 servings', mockData, context);
    expect(result.context.budget).toBe(20);
    expect(result.context.servings).toBe(2);
  });

  test('should handle budget input without servings', async () => {
    const context = { budgetFlow: 'awaiting_budget' };
    const result = await processMessage('under $15', mockData, context);
    expect(result.context.budget).toBe(15);
    expect(result.context.servings).toBe(2); // default
  });

  test('should reject invalid budget input', async () => {
    const context = { budgetFlow: 'awaiting_budget' };
    const result = await processMessage('I have no money', mockData, context);
    expect(result.reply).toContain('specify a dollar budget');
  });
});

describe('chatLogic - Time Flow', () => {
  test('should parse time input in minutes', async () => {
    const context = { timeFlow: 'awaiting_minutes' };
    const result = await processMessage('30 minutes', mockData, context);
    expect(result.context.minutes).toBe(30);
  });

  test('should handle time input with "under" prefix', async () => {
    const context = { timeFlow: 'awaiting_minutes' };
    const result = await processMessage('under 20', mockData, context);
    expect(result.context.minutes).toBe(20);
  });

  test('should reject invalid time input', async () => {
    const context = { timeFlow: 'awaiting_minutes' };
    const result = await processMessage('very quick', mockData, context);
    expect(result.reply).toContain('minutes you have');
  });
});

describe('chatLogic - Meal Prep Flow', () => {
  test('should handle numbered preference selection', async () => {
    const context = { mealPrepFlow: 'awaiting_preference' };
    const result = await processMessage('1', mockData, context);
    expect(result.recipes).toBeDefined();
  });

  test('should handle text preference selection', async () => {
    const context = { mealPrepFlow: 'awaiting_preference' };
    const result = await processMessage('vegetarian', mockData, context);
    expect(result.recipes).toBeDefined();
  });

  test('should reject invalid preference', async () => {
    const context = { mealPrepFlow: 'awaiting_preference' };
    const result = await processMessage('x', mockData, context);
    expect(result.reply).toContain('type of recipes');
  });
});

describe('chatLogic - suggestRecipes', () => {
  test('should return recipes based on query', () => {
    const result = suggestRecipes('dinner', mockData, 2);
    expect(result.recipes).toBeDefined();
    expect(Array.isArray(result.recipes)).toBe(true);
  });

  test('should respect recipe count parameter', () => {
    const result = suggestRecipes('quick meal', mockData, 1);
    expect(result.recipes.length).toBeLessThanOrEqual(1);
  });

  test('should handle empty query', () => {
    const result = suggestRecipes('', mockData, 3);
    expect(result.recipes).toBeDefined();
  });
});

describe('chatLogic - Error Handling', () => {
  test('should handle missing data gracefully', async () => {
    const emptyData = { products: [], recipes: [] };
    const result = await processMessage('give me recipes', emptyData, {});
    expect(result).toBeDefined();
    expect(result.reply).toBeDefined();
  });

  test('should handle undefined message', async () => {
    await expect(processMessage(undefined, mockData, {})).rejects.toThrow();
  });

  test('should handle null data', async () => {
    // The actual code handles null data gracefully by falling back to LLM
    const result = await processMessage('hello', null, {});
    expect(result).toBeDefined();
    expect(result.reply).toBeDefined();
  });

  test('should handle malformed context', async () => {
    // Passing null context should be handled by initializing a new context
    await expect(processMessage('hi', mockData, null)).rejects.toThrow();
  });
});
