const axios = require('axios');
// Provider selection: default to OpenAI if OPENAI_API_KEY is set and non-empty, else use local Ollama
const hasValidOpenAIKey = process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY.trim().length > 0;
const PROVIDER = process.env.LLM_PROVIDER || (hasValidOpenAIKey ? 'openai' : 'ollama');
const OPENAI_MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini';

const OLLAMA_URL = process.env.OLLAMA_URL || 'http://localhost:11434';
const OLLAMA_MODEL = process.env.OLLAMA_MODEL || 'qwen2.5:7b';
const OLLAMA_API_KEY = process.env.OLLAMA_API_KEY || '';
const SYSTEM_PROMPT = `You are a helpful grocery and recipe assistant.

Your core capabilities:
- Recipe Recommendation from Datasets: Analyze provided product and recipe datasets to recommend practical, cost-effective meals.
- Creative Recipe Generation: Invent new recipes using only products available in the product dataset; keep suggestions realistic and grounded.
- Occasion-Based Suggestions: Recommend recipes suited to occasions (birthday party, casual dinner, office lunch, picnic, festive event), balancing meal type, serving size, and prep time.
- Automated Meal Classification: Classify recipes as breakfast, lunch, dinner, snack, dessert, or quick meal.
- Personalized and Adaptive: Adapt to user preferences, dietary needs, favorite cuisines, and budget constraints using conversation context.

Tone & Style:
- Warm, enthusiastic, concise (2-4 sentences), and helpful.
- Mention recipe names naturally. Encourage clicking "Add Ingredients" for shopping list and "More" for additional ideas.
- Never invent products not in the product dataset. When generating new recipes, only use available products.

Output discipline:
- When asked to suggest recipes, you MUST be able to produce a compact JSON result when requested, including recipes with ingredients and steps. If not explicitly requested for JSON, you may respond naturally.
- NEVER include chain-of-thought or internal reasoning. Do NOT output <think> sections. In JSON mode, output JSON only with no preface or suffix.`;

// Helper to extract partial recipes when JSON is malformed
function extractPartialRecipes(content, requestedCount = 3) {
    const recipes = [];
    
    // Try to extract recipe names and basic info
    const nameMatches = content.matchAll(/"name"\s*:\s*"([^"]+)"/g);
    const names = Array.from(nameMatches).map(m => m[1]);
    
    for (let i = 0; i < Math.min(names.length, requestedCount); i++) {
        recipes.push({
            name: names[i],
            ingredients: ['Ingredients unavailable (JSON parse error)'],
            steps: ['Recipe details unavailable. Please try asking again.'],
            mealType: 'quick meal',
            autogenerated: true
        });
    }
    
    // If we got at least one recipe, return it
    if (recipes.length > 0) {
        return {
            reply: `Here ${recipes.length === 1 ? 'is a' : 'are'} ${recipes.length} recipe${recipes.length > 1 ? 's' : ''} (partial due to formatting error):`,
            recipes
        };
    }
    
    // Complete fallback
    return {
        reply: "I'm having trouble generating recipes right now. Could you try rephrasing your request?",
        recipes: []
    };
}

// Natural language response (concise, conversational) â€” Ollama implementation
async function chatWithOllama(message, context = [], recipes = [], products = []) {
    try {
        // Build conversation context
        const messages = [
            { role: 'system', content: SYSTEM_PROMPT }
        ];
        
        // Add conversation history (last few messages)
        if (context && context.length > 0) {
            context.forEach(msg => {
                messages.push({
                    role: msg.from === 'user' ? 'user' : 'assistant',
                    content: msg.text
                });
            });
        }
        
        // Add current user message with recipe context
        let userPrompt = message;
        if (recipes && recipes.length > 0) {
            const recipeNames = recipes.map(r => r.name).join(', ');
            userPrompt = `User message: "${message}"\n\nRecipes found for this request: ${recipeNames}\n\nRespond naturally and mention these recipes by name. Keep it brief and friendly!`;
        }
        
        messages.push({ role: 'user', content: userPrompt });

        console.log('Calling Ollama API (natural response)...');
        const response = await axios.post(`${OLLAMA_URL}/api/chat`, {
            model: OLLAMA_MODEL,
            messages,
            stream: false,
            options: {
                temperature: 0.7,
                num_predict: 300 // Increased from 150 to allow complete responses
            }
        }, {
            timeout: 60000, // 60 second timeout (increased from 30s for slower responses)
            headers: OLLAMA_API_KEY ? { Authorization: `Bearer ${OLLAMA_API_KEY}` } : undefined
        });

        console.log('Ollama response received');
        return response.data.message.content;
    } catch (error) {
        if (error.code === 'ECONNREFUSED') {
            console.error('Ollama is not running. Please start Ollama service.');
            return "I'm having trouble connecting to my AI brain ðŸ§ . Please make sure Ollama is running! You can start it with 'ollama serve' in your terminal.";
        }
        if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
            console.error('Ollama request timed out');
            return "I'm taking too long to think ðŸ¤”. The AI model might be slow or overloaded. Try a simpler question or wait a moment and try again!";
        }
        console.error('Ollama chat error:', error.message);
        throw error; // Let the caller handle fallback
    }
}

// Structured suggestion call: returns JSON with reply + recipes â€” Ollama implementation
async function suggestWithOllama({ message, context = [], recipeCatalog = [], productList = [], avoidNames = [], groundedMode = false, requestedCount = 3 }) {
        // Lightweight system prompt for fast, creative generation
        const recipeCount = requestedCount || 3;
        let system = `You are a recipe assistant. Generate EXACTLY ${recipeCount} ${recipeCount === 1 ? 'recipe' : 'recipes'}.

CRITICAL: Return ONLY valid JSON. No markdown, no text before or after. Use this EXACT format:
{
    "reply": "Here are ${recipeCount} recipes for you!",
    "reasoning": "Brief 1-2 sentence explanation of why these recipes were chosen based on the user's request",
    "recipes": [
        {
            "name": "Recipe Name Here",
            "ingredients": ["ingredient 1", "ingredient 2", "ingredient 3"],
            "steps": ["step 1", "step 2", "step 3"],
            "mealType": "dinner",
            "autogenerated": true
        }
    ]
}

Rules:
- Generate EXACTLY ${recipeCount} recipe objects in the recipes array
- Include a "reasoning" field explaining why these recipes fit the user's request
- Each recipe MUST have all 5 fields: name, ingredients (array), steps (array), mealType, autogenerated
- NO trailing commas in arrays or objects
- NO extra text outside the JSON
- Steps must be an array of strings, not a single string
- Common pantry items only`;

        // Grounded mode optionally constrains ingredients strictly to the product list
        let groundedAppendix = '';
        if (groundedMode) {
            // Compress productList to a simple unique name list (limit to avoid huge prompts)
            const names = Array.from(new Set((productList || []).map(p => (p.item || '').toString().trim()).filter(Boolean)));
            const limited = names.slice(0, 300); // cap for safety
            groundedAppendix = `\n\nIMPORTANT (Grounded Mode): Only use ingredients from THIS allowed list. Do not include anything else. If something is missing, propose a substitution from this list.\nAllowed products (names, case-insensitive):\n- ${limited.join('\n- ')}`;
        }

        // Avoid repeating already-suggested recipe names
        const avoidList = (avoidNames || []).filter(Boolean).slice(-50); // keep small
        const avoidAppendix = avoidList.length > 0 ? `\n\nAvoid suggesting recipes with these names (or trivial variants): ${avoidList.join(', ')}` : '';

        system += groundedAppendix + avoidAppendix;

        const messages = [
                { role: 'system', content: system }
        ];

    // Add brief conversation history
    (context || []).slice(-6).forEach(msg => messages.push({
        role: msg.from === 'user' ? 'user' : 'assistant',
        content: msg.text
    }));

    messages.push({ role: 'user', content: message });

    try {
        console.log('Calling Ollama API (structured suggestions)...');
        const response = await axios.post(`${OLLAMA_URL}/api/chat`, {
            model: OLLAMA_MODEL,
            messages,
            stream: false,
            format: 'json',
            options: { temperature: groundedMode ? 0.3 : 0.5, num_predict: 2000 }
        }, { timeout: 90000, headers: OLLAMA_API_KEY ? { Authorization: `Bearer ${OLLAMA_API_KEY}` } : undefined });

        const content = response?.data?.message?.content || '';
        // Attempt to locate JSON in content
        const jsonStart = content.indexOf('{');
        const jsonEnd = content.lastIndexOf('}');
        const jsonText = jsonStart >= 0 && jsonEnd > jsonStart ? content.slice(jsonStart, jsonEnd + 1) : content;
        
        try {
            const parsed = JSON.parse(jsonText);
            return parsed;
        } catch (parseErr) {
            console.error('JSON parse error:', parseErr.message);
            console.log('Raw content:', content.substring(0, 600));
            
            // Try to repair common JSON issues
            let repaired = jsonText
                .replace(/,\s*]/g, ']')  // Remove trailing commas in arrays
                .replace(/,\s*}/g, '}')  // Remove trailing commas in objects
                .replace(/}\s*{/g, '},{') // Fix missing commas between objects
                .replace(/"\s*\n\s*"/g, '", "'); // Fix line breaks in strings
            
            try {
                const parsed = JSON.parse(repaired);
                console.log('âœ“ JSON repaired successfully');
                return parsed;
            } catch (repairErr) {
                // Last resort: extract what we can
                console.error('JSON repair failed, using fallback extraction');
                return extractPartialRecipes(content, recipeCount);
            }
        }
    } catch (err) {
        console.error('Ollama structured suggestion error:', err.message);
        throw err;
    }
}

// -------------------- OpenAI implementations --------------------
async function chatWithOpenAI(message, context = [], recipes = [], products = []) {
    try {
        // Lazy import to avoid requiring when not needed
        const OpenAI = require('openai');
        // Allow OpenAI-compatible providers via custom base URL
        const openai = new OpenAI({ 
            apiKey: process.env.OPENAI_API_KEY, 
            baseURL: process.env.OPENAI_BASE_URL || undefined 
        });

        const messages = [ { role: 'system', content: SYSTEM_PROMPT } ];
        if (Array.isArray(context) && context.length > 0) {
            context.forEach(msg => messages.push({
                role: msg.from === 'user' ? 'user' : 'assistant',
                content: msg.text
            }));
        }
        let userPrompt = message;
        if (recipes && recipes.length > 0) {
            const recipeNames = recipes.map(r => r.name).join(', ');
            userPrompt = `User message: "${message}"\n\nRecipes found for this request: ${recipeNames}\n\nRespond naturally and mention these recipes by name. Keep it brief and friendly!`;
        }
        messages.push({ role: 'user', content: userPrompt });

        const resp = await openai.chat.completions.create({
            model: OPENAI_MODEL,
            messages,
            temperature: 0.7,
            max_tokens: 300
        });
        const content = resp?.choices?.[0]?.message?.content || '';
        return content;
    } catch (error) {
        if (error?.status === 401 || /invalid api key/i.test(error?.message || '')) {
            return "Your OpenAI API key seems invalid. Please set a valid OPENAI_API_KEY in your environment.";
        }
        if (/insufficient_quota|rate limit/i.test(error?.message || '')) {
            return "The OpenAI API quota was exceeded. Please try again later or adjust your usage.";
        }
        console.error('OpenAI chat error:', error?.message || error);
        throw error;
    }
}

async function suggestWithOpenAI({ message, context = [], recipeCatalog = [], productList = [], avoidNames = [], groundedMode = false, requestedCount = 3 }) {
    try {
        const OpenAI = require('openai');
        const openai = new OpenAI({ 
            apiKey: process.env.OPENAI_API_KEY,
            baseURL: process.env.OPENAI_BASE_URL || undefined
        });

        const recipeCount = requestedCount || 3;
        let system = SYSTEM_PROMPT + `\n\nWhen the user asks for recipes, respond with STRICT JSON (no markdown) in this schema and generate exactly ${recipeCount} ${recipeCount === 1 ? 'recipe' : 'recipes'}:\n{
    "reply": string,
    "reasoning": string,
    "recipes": [
        {
            "name": string,
            "ingredients": string[],
            "steps": string[] | string,
            "mealType": "breakfast"|"lunch"|"dinner"|"snack"|"dessert"|"quick meal",
            "autogenerated": true
        }
    ]
}\nRules: JSON only, no backticks. Include a "reasoning" field explaining why these recipes fit the request. Prefer common pantry items. Keep steps short.`;

        if (groundedMode) {
            const names = Array.from(new Set((productList || []).map(p => (p.item || '').toString().trim()).filter(Boolean)));
            const limited = names.slice(0, 300);
            system += `\n\nIMPORTANT (Grounded Mode): Only use ingredients from THIS allowed list. Do not include anything else. If something is missing, propose a substitution from this list.\nAllowed products (names, case-insensitive):\n- ${limited.join('\n- ')}`;
        }
        const avoidList = (avoidNames || []).filter(Boolean).slice(-50);
        if (avoidList.length > 0) {
            system += `\n\nAvoid suggesting recipes with these names (or trivial variants): ${avoidList.join(', ')}`;
        }

        const messages = [ { role: 'system', content: system } ];
        (context || []).slice(-6).forEach(msg => messages.push({
            role: msg.from === 'user' ? 'user' : 'assistant',
            content: msg.text
        }));
        messages.push({ role: 'user', content: message });

        const resp = await openai.chat.completions.create({
            model: OPENAI_MODEL,
            messages,
            temperature: groundedMode ? 0.3 : 0.5,
            max_tokens: 500,
            response_format: { type: 'json_object' }
        });
        const content = resp?.choices?.[0]?.message?.content || '{}';
        const parsed = JSON.parse(content);
        return parsed;
    } catch (error) {
        if (error?.status === 401 || /invalid api key/i.test(error?.message || '')) {
            throw new Error('Invalid OpenAI API key');
        }
        console.error('OpenAI structured suggestion error:', error?.message || error);
        throw error;
    }
}

// Choose provider at export time
const useOpenAI = PROVIDER === 'openai';
const chatExport = useOpenAI ? chatWithOpenAI : chatWithOllama;
const suggestExport = useOpenAI ? suggestWithOpenAI : suggestWithOllama;

module.exports = { chatWithOllama: chatExport, suggestWithOllama: suggestExport };